"""
Strategy Base Module - Abstract base class for trading strategies

Provides the interface that all strategies must implement.
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass
from datetime import datetime
from enum import Enum
from typing import Dict, List, Optional

import pandas as pd


class SignalType(Enum):
    """Trading signal types."""
    BUY = 1
    SELL = -1
    HOLD = 0


@dataclass
class Signal:
    """Trading signal generated by strategy."""
    stock_code: str
    signal: SignalType
    date: datetime
    price: float = 0.0
    quantity: int = 0  # 0 means use default sizing
    reason: str = ""

    def __post_init__(self):
        if isinstance(self.signal, int):
            self.signal = SignalType(self.signal)


@dataclass
class Context:
    """
    Context object passed to strategy on each bar.

    Contains current portfolio state, historical data, and utility methods.
    """
    date: datetime
    current_prices: Dict[str, float]
    portfolio_value: float
    cash: float
    positions: Dict[str, int]  # stock_code -> quantity

    # Historical data
    data: pd.DataFrame  # OHLCV data up to current date

    # Indicators (calculated by strategy in init)
    indicators: Dict[str, pd.Series] = None

    def __post_init__(self):
        if self.indicators is None:
            self.indicators = {}

    def get_price(self, stock_code: str) -> Optional[float]:
        """Get current price for a stock."""
        return self.current_prices.get(stock_code)

    def has_position(self, stock_code: str) -> bool:
        """Check if we have a position in the stock."""
        return self.positions.get(stock_code, 0) > 0

    def get_position_size(self, stock_code: str) -> int:
        """Get position size for a stock."""
        return self.positions.get(stock_code, 0)


class Strategy(ABC):
    """
    Abstract base class for trading strategies.

    All custom strategies must inherit from this class and implement
    the `init` and `next` methods.

    Example:
        class MyStrategy(Strategy):
            def init(self, data: pd.DataFrame):
                # Calculate indicators
                self.sma20 = data['close'].rolling(20).mean()

            def next(self, context: Context) -> Optional[Signal]:
                # Generate signals
                if context.data['close'][-1] > self.sma20[-1]:
                    return Signal(stock_code='000001', signal=SignalType.BUY)
                return None
    """

    def __init__(self, name: str = "UnnamedStrategy"):
        self.name = name
        self.data: Optional[pd.DataFrame] = None
        self.indicators: Dict[str, pd.Series] = {}
        self._initialized = False

    def init(self, data: pd.DataFrame):
        """
        Initialize strategy with historical data.

        Called once before backtest starts. Calculate indicators here.

        Args:
            data: Historical OHLCV DataFrame with columns:
                  date, open, high, low, close, volume, ...
        """
        self.data = data.copy()
        self._calculate_indicators()
        self._initialized = True

    def _calculate_indicators(self):
        """
        Calculate strategy indicators.

        Override this method to define custom indicators.
        Base implementation calculates basic moving averages.
        """
        # Default: calculate basic MAs
        if 'close' in self.data.columns:
            self.indicators['sma20'] = self.data['close'].rolling(window=20).mean()
            self.indicators['sma60'] = self.data['close'].rolling(window=60).mean()

    @abstractmethod
    def next(self, context: Context) -> Optional[Signal]:
        """
        Called on each bar/day during backtest.

        Implement trading logic here. Return a Signal to execute trade,
        or None to do nothing.

        Args:
            context: Current market and portfolio context

        Returns:
            Signal object or None
        """
        pass

    def on_trade(self, signal: Signal, fill_price: float, quantity: int):
        """
        Called after a trade is executed.

        Override to track trades or update strategy state.

        Args:
            signal: The signal that triggered the trade
            fill_price: Actual execution price
            quantity: Executed quantity
        """
        pass

    def get_indicator(self, name: str, index: int = -1) -> Optional[float]:
        """
        Get indicator value at specified index.

        Args:
            name: Indicator name
            index: DataFrame index (default -1 = current)

        Returns:
            Indicator value or None
        """
        if name not in self.indicators:
            return None
        try:
            return self.indicators[name].iloc[index]
        except IndexError:
            return None


class BuyAndHoldStrategy(Strategy):
    """Simple buy and hold strategy for testing."""

    def __init__(self, stock_code: str):
        super().__init__("BuyAndHold")
        self.stock_code = stock_code
        self.bought = False

    def init(self, data: pd.DataFrame):
        super().init(data)

    def next(self, context: Context) -> Optional[Signal]:
        if not self.bought and not context.has_position(self.stock_code):
            self.bought = True
            return Signal(
                stock_code=self.stock_code,
                signal=SignalType.BUY,
                date=context.date,
                price=context.get_price(self.stock_code),
                reason="Initial buy"
            )
        return None


if __name__ == "__main__":
    # Test base strategy
    print("Testing Strategy Base with 601012 (隆基绿能)...")
    print("=" * 50)

    import sys
    sys.path.insert(0, '/Users/kannmu/Library/CloudStorage/OneDrive-Personal/Projects/K-Quant/src')

    from data_loader import load_stock_data

    # Load data
    data = load_stock_data("601012", "20240101", "20241231", include_fundamental=False)
    print(f"\n1. Loaded {len(data)} rows of data for 601012")
    print(f"   Date range: {data['date'].min()} to {data['date'].max()}")

    # Test BuyAndHold strategy
    print("\n2. Testing BuyAndHoldStrategy...")
    strategy = BuyAndHoldStrategy("601012")
    strategy.init(data)

    print(f"   Strategy initialized: {strategy._initialized}")
    print(f"   Available indicators: {list(strategy.indicators.keys())}")

    # Simulate a few bars
    for i in range(60, 65):
        row = data.iloc[i]
        context = Context(
            date=row['date'],
            current_prices={"601012": row['close']},
            portfolio_value=100000,
            cash=100000,
            positions={},
            data=data.iloc[:i+1],
            indicators=strategy.indicators
        )
        signal = strategy.next(context)
        if signal:
            print(f"   Signal on {row['date']}: {signal.signal.name} - {signal.reason}")

    print("\n✅ Strategy base test completed!")
